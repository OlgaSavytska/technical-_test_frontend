{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nvar newline = /\\n/;\nvar newlineChar = '\\n';\nvar whitespace = /\\s/;\nmodule.exports = function (text, opt) {\n  var lines = module.exports.lines(text, opt);\n  return lines.map(function (line) {\n    return text.substring(line.start, line.end);\n  }).join('\\n');\n};\nmodule.exports.lines = function wordwrap(text, opt) {\n  opt = opt || {};\n\n  //zero width results in nothing visible\n  if (opt.width === 0 && opt.mode !== 'nowrap') return [];\n  text = text || '';\n  var width = typeof opt.width === 'number' ? opt.width : Number.MAX_VALUE;\n  var start = Math.max(0, opt.start || 0);\n  var end = typeof opt.end === 'number' ? opt.end : text.length;\n  var mode = opt.mode;\n  var measure = opt.measure || monospace;\n  if (mode === 'pre') return pre(measure, text, start, end, width);else return greedy(measure, text, start, end, width, mode);\n};\nfunction idxOf(text, chr, start, end) {\n  var idx = text.indexOf(chr, start);\n  if (idx === -1 || idx > end) return end;\n  return idx;\n}\nfunction isWhitespace(chr) {\n  return whitespace.test(chr);\n}\nfunction pre(measure, text, start, end, width) {\n  var lines = [];\n  var lineStart = start;\n  for (var i = start; i < end && i < text.length; i++) {\n    var chr = text.charAt(i);\n    var isNewline = newline.test(chr);\n\n    //If we've reached a newline, then step down a line\n    //Or if we've reached the EOF\n    if (isNewline || i === end - 1) {\n      var lineEnd = isNewline ? i : i + 1;\n      var measured = measure(text, lineStart, lineEnd, width);\n      lines.push(measured);\n      lineStart = i + 1;\n    }\n  }\n  return lines;\n}\nfunction greedy(measure, text, start, end, width, mode) {\n  //A greedy word wrapper based on LibGDX algorithm\n  //https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java\n  var lines = [];\n  var testWidth = width;\n  //if 'nowrap' is specified, we only wrap on newline chars\n  if (mode === 'nowrap') testWidth = Number.MAX_VALUE;\n  while (start < end && start < text.length) {\n    //get next newline position\n    var newLine = idxOf(text, newlineChar, start, end);\n\n    //eat whitespace at start of line\n    while (start < newLine) {\n      if (!isWhitespace(text.charAt(start))) break;\n      start++;\n    }\n\n    //determine visible # of glyphs for the available width\n    var measured = measure(text, start, newLine, testWidth);\n    var lineEnd = start + (measured.end - measured.start);\n    var nextStart = lineEnd + newlineChar.length;\n\n    //if we had to cut the line before the next newline...\n    if (lineEnd < newLine) {\n      //find char to break on\n      while (lineEnd > start) {\n        if (isWhitespace(text.charAt(lineEnd))) break;\n        lineEnd--;\n      }\n      if (lineEnd === start) {\n        if (nextStart > start + newlineChar.length) nextStart--;\n        lineEnd = nextStart; // If no characters to break, show all.\n      } else {\n        nextStart = lineEnd;\n        //eat whitespace at end of line\n        while (lineEnd > start) {\n          if (!isWhitespace(text.charAt(lineEnd - newlineChar.length))) break;\n          lineEnd--;\n        }\n      }\n    }\n    if (lineEnd >= start) {\n      var result = measure(text, start, lineEnd, testWidth);\n      lines.push(result);\n    }\n    start = nextStart;\n  }\n  return lines;\n}\n\n//determines the visible number of glyphs within a given width\nfunction monospace(text, start, end, width) {\n  var glyphs = Math.min(width, end - start);\n  return {\n    start: start,\n    end: start + glyphs\n  };\n}","map":{"version":3,"names":["newline","newlineChar","whitespace","module","exports","text","opt","lines","map","line","substring","start","end","join","wordwrap","width","mode","Number","MAX_VALUE","Math","max","length","measure","monospace","pre","greedy","idxOf","chr","idx","indexOf","isWhitespace","test","lineStart","i","charAt","isNewline","lineEnd","measured","push","testWidth","newLine","nextStart","result","glyphs","min"],"sources":["/Users/olga/Desktop/parallaxTest/node_modules/word-wrapper/index.js"],"sourcesContent":["var newline = /\\n/\nvar newlineChar = '\\n'\nvar whitespace = /\\s/\n\nmodule.exports = function(text, opt) {\n    var lines = module.exports.lines(text, opt)\n    return lines.map(function(line) {\n        return text.substring(line.start, line.end)\n    }).join('\\n')\n}\n\nmodule.exports.lines = function wordwrap(text, opt) {\n    opt = opt||{}\n\n    //zero width results in nothing visible\n    if (opt.width === 0 && opt.mode !== 'nowrap') \n        return []\n\n    text = text||''\n    var width = typeof opt.width === 'number' ? opt.width : Number.MAX_VALUE\n    var start = Math.max(0, opt.start||0)\n    var end = typeof opt.end === 'number' ? opt.end : text.length\n    var mode = opt.mode\n\n    var measure = opt.measure || monospace\n    if (mode === 'pre')\n        return pre(measure, text, start, end, width)\n    else\n        return greedy(measure, text, start, end, width, mode)\n}\n\nfunction idxOf(text, chr, start, end) {\n    var idx = text.indexOf(chr, start)\n    if (idx === -1 || idx > end)\n        return end\n    return idx\n}\n\nfunction isWhitespace(chr) {\n    return whitespace.test(chr)\n}\n\nfunction pre(measure, text, start, end, width) {\n    var lines = []\n    var lineStart = start\n    for (var i=start; i<end && i<text.length; i++) {\n        var chr = text.charAt(i)\n        var isNewline = newline.test(chr)\n\n        //If we've reached a newline, then step down a line\n        //Or if we've reached the EOF\n        if (isNewline || i===end-1) {\n            var lineEnd = isNewline ? i : i+1\n            var measured = measure(text, lineStart, lineEnd, width)\n            lines.push(measured)\n            \n            lineStart = i+1\n        }\n    }\n    return lines\n}\n\nfunction greedy(measure, text, start, end, width, mode) {\n    //A greedy word wrapper based on LibGDX algorithm\n    //https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java\n    var lines = []\n\n    var testWidth = width\n    //if 'nowrap' is specified, we only wrap on newline chars\n    if (mode === 'nowrap')\n        testWidth = Number.MAX_VALUE\n\n    while (start < end && start < text.length) {\n        //get next newline position\n        var newLine = idxOf(text, newlineChar, start, end)\n\n        //eat whitespace at start of line\n        while (start < newLine) {\n            if (!isWhitespace( text.charAt(start) ))\n                break\n            start++\n        }\n\n        //determine visible # of glyphs for the available width\n        var measured = measure(text, start, newLine, testWidth)\n\n        var lineEnd = start + (measured.end-measured.start)\n        var nextStart = lineEnd + newlineChar.length\n\n        //if we had to cut the line before the next newline...\n        if (lineEnd < newLine) {\n            //find char to break on\n            while (lineEnd > start) {\n                if (isWhitespace(text.charAt(lineEnd)))\n                    break\n                lineEnd--\n            }\n            if (lineEnd === start) {\n                if (nextStart > start + newlineChar.length) nextStart--\n                lineEnd = nextStart // If no characters to break, show all.\n            } else {\n                nextStart = lineEnd\n                //eat whitespace at end of line\n                while (lineEnd > start) {\n                    if (!isWhitespace(text.charAt(lineEnd - newlineChar.length)))\n                        break\n                    lineEnd--\n                }\n            }\n        }\n        if (lineEnd >= start) {\n            var result = measure(text, start, lineEnd, testWidth)\n            lines.push(result)\n        }\n        start = nextStart\n    }\n    return lines\n}\n\n//determines the visible number of glyphs within a given width\nfunction monospace(text, start, end, width) {\n    var glyphs = Math.min(width, end-start)\n    return {\n        start: start,\n        end: start+glyphs\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}